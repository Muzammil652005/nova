// node_modules/@oslojs/binary/dist/uint.js
var BigEndian = class {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] << 8 | data[offset + 1];
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i = 0; i < 4; i++) {
      result |= data[offset + i] << 24 - i * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i = 0; i < 8; i++) {
      result |= BigInt(data[offset + i]) << BigInt(56 - i * 8);
    }
    return result;
  }
  putUint8(target, value, offset) {
    if (target.length < offset + 1) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value;
  }
  putUint16(target, value, offset) {
    if (target.length < offset + 2) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset] = value >> 8;
    target[offset + 1] = value & 255;
  }
  putUint32(target, value, offset) {
    if (target.length < offset + 4) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i = 0; i < 4; i++) {
      target[offset + i] = value >> (3 - i) * 8 & 255;
    }
  }
  putUint64(target, value, offset) {
    if (target.length < offset + 8) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i = 0; i < 8; i++) {
      target[offset + i] = Number(value >> BigInt((7 - i) * 8) & 0xffn);
    }
  }
};
var LittleEndian = class {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] | data[offset + 1] << 8;
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i = 0; i < 4; i++) {
      result |= data[offset + i] << i * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i = 0; i < 8; i++) {
      result |= BigInt(data[offset + i]) << BigInt(i * 8);
    }
    return result;
  }
  putUint8(target, value, offset) {
    if (target.length < 1 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value;
  }
  putUint16(target, value, offset) {
    if (target.length < 2 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset + 1] = value >> 8;
    target[offset] = value & 255;
  }
  putUint32(target, value, offset) {
    if (target.length < 4 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i = 0; i < 4; i++) {
      target[offset + i] = value >> i * 8 & 255;
    }
  }
  putUint64(target, value, offset) {
    if (target.length < 8 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i = 0; i < 8; i++) {
      target[offset + i] = Number(value >> BigInt(i * 8) & 0xffn);
    }
  }
};
var bigEndian = new BigEndian();
var littleEndian = new LittleEndian();

// node_modules/@oslojs/binary/dist/bits.js
function rotl64(x, n) {
  return (x << BigInt(n) | x >> BigInt(64 - n)) & 0xffffffffffffffffn;
}

// node_modules/@oslojs/crypto/dist/sha3/sha3.js
var SHA3 = class {
  rate;
  outputSize;
  state = new BigUint64Array(25);
  absorbedBytes = 0;
  constructor(rate, outputSize) {
    this.rate = rate;
    this.outputSize = outputSize;
  }
  absorb(bytes) {
    for (let i = 0; i < bytes.byteLength; i++) {
      this.state[Math.floor(this.absorbedBytes / 8)] ^= BigInt(bytes[i]) << BigInt(this.absorbedBytes % 8) * 8n;
      this.absorbedBytes++;
      if (this.absorbedBytes === this.rate) {
        keccak(this.state);
        this.absorbedBytes = 0;
      }
    }
  }
  squeeze() {
    this.state[Math.floor(this.absorbedBytes / 8)] ^= 0x06n << BigInt(this.absorbedBytes % 8) * 8n;
    this.state[Math.floor((this.rate - 1) / 8)] ^= 0x8000000000000000n;
    keccak(this.state);
    if (this.outputSize <= this.rate) {
      return new Uint8Array(this.state.buffer).slice(0, this.outputSize);
    }
    const keccakCount = Math.ceil(this.outputSize / this.rate);
    const z = new Uint8Array(keccakCount * this.rate);
    z.set(new Uint8Array(this.state.buffer).slice(0, this.rate));
    for (let i = 1; i < keccakCount; i++) {
      keccak(this.state);
      z.set(new Uint8Array(this.state.buffer).slice(0, this.rate), i * this.rate);
    }
    return z.slice(0, this.outputSize);
  }
};
var SHA3XOF = class {
  rate;
  outputSize;
  state = new BigUint64Array(25);
  absorbedBytes = 0;
  constructor(rate, outputSize) {
    this.rate = rate;
    this.outputSize = outputSize;
  }
  absorb(bytes) {
    for (let i = 0; i < bytes.byteLength; i++) {
      this.state[Math.floor(this.absorbedBytes / 8)] ^= BigInt(bytes[i]) << BigInt(this.absorbedBytes % 8) * 8n;
      this.absorbedBytes++;
      if (this.absorbedBytes === this.rate) {
        keccak(this.state);
        this.absorbedBytes = 0;
      }
    }
  }
  squeeze() {
    this.state[Math.floor(this.absorbedBytes / 8)] ^= 0x1fn << BigInt(this.absorbedBytes % 8) * 8n;
    this.state[Math.floor((this.rate - 1) / 8)] ^= 0x8000000000000000n;
    keccak(this.state);
    if (this.outputSize <= this.rate) {
      return new Uint8Array(this.state.buffer).slice(0, this.outputSize);
    }
    const keccakCount = Math.ceil(this.outputSize / this.rate);
    const z = new Uint8Array(keccakCount * this.rate);
    z.set(new Uint8Array(this.state.buffer).slice(0, this.rate));
    for (let i = 1; i < keccakCount; i++) {
      keccak(this.state);
      z.set(new Uint8Array(this.state.buffer).slice(0, this.rate), i * this.rate);
    }
    return z.slice(0, this.outputSize);
  }
};
function keccak(a) {
  for (let i = 0; i < 24; i++) {
    theta(a);
    rho(a);
    pi(a);
    chi(a);
    iota(a, i);
  }
}
function theta(a) {
  const c = new BigUint64Array(5);
  for (let x = 0; x < 5; x++) {
    c[x] = a[x];
    c[x] ^= a[x + 5];
    c[x] ^= a[x + 10];
    c[x] ^= a[x + 15];
    c[x] ^= a[x + 20];
  }
  const d = new BigUint64Array(5);
  for (let x = 0; x < 5; x++) {
    d[x] = c[(x + 4) % 5] ^ rotl64(c[(x + 1) % 5], 1);
  }
  for (let x = 0; x < 5; x++) {
    for (let y = 0; y < 5; y++) {
      a[x + y * 5] ^= d[x];
    }
  }
}
function rho(a) {
  const shifts = [
    0,
    1,
    62,
    28,
    27,
    36,
    44,
    6,
    55,
    20,
    3,
    10,
    43,
    25,
    39,
    41,
    45,
    15,
    21,
    8,
    18,
    2,
    61,
    56,
    14
  ];
  for (let i = 0; i < 25; i++) {
    a[i] = rotl64(a[i], shifts[i]);
  }
}
function pi(a) {
  const dests = [
    0,
    10,
    20,
    5,
    15,
    16,
    1,
    11,
    21,
    6,
    7,
    17,
    2,
    12,
    22,
    23,
    8,
    18,
    3,
    13,
    14,
    24,
    9,
    19,
    4
  ];
  const temp = new BigUint64Array(a);
  for (let i = 0; i < 25; i++) {
    a[dests[i]] = temp[i];
  }
}
function chi(a) {
  const temp = new BigUint64Array(a);
  for (let x = 0; x < 5; x++) {
    for (let y = 0; y < 5; y++) {
      a[x + 5 * y] ^= ~temp[(x + 1) % 5 + 5 * y] & temp[(x + 2) % 5 + 5 * y];
    }
  }
}
function iota(a, i) {
  a[0] ^= iotaConstants[i];
}
var iotaConstants = new BigUint64Array([
  0x0000000000000001n,
  0x0000000000008082n,
  0x800000000000808an,
  0x8000000080008000n,
  0x000000000000808bn,
  0x0000000080000001n,
  0x8000000080008081n,
  0x8000000000008009n,
  0x000000000000008an,
  0x0000000000000088n,
  0x0000000080008009n,
  0x000000008000000an,
  0x000000008000808bn,
  0x800000000000008bn,
  0x8000000000008089n,
  0x8000000000008003n,
  0x8000000000008002n,
  0x8000000000000080n,
  0x000000000000800an,
  0x800000008000000an,
  0x8000000080008081n,
  0x8000000000008080n,
  0x0000000080000001n,
  0x8000000080008008n
]);

// node_modules/@oslojs/crypto/dist/sha3/hash.js
function sha3_224(data) {
  const hash = new SHA3_224();
  hash.update(data);
  return hash.digest();
}
function sha3_256(data) {
  const hash = new SHA3_256();
  hash.update(data);
  return hash.digest();
}
function sha3_384(data) {
  const hash = new SHA3_384();
  hash.update(data);
  return hash.digest();
}
function sha3_512(data) {
  const hash = new SHA3_512();
  hash.update(data);
  return hash.digest();
}
var SHA3_224 = class {
  blockSize = 144;
  size = 28;
  sha3 = new SHA3(this.blockSize, this.size);
  update(data) {
    this.sha3.absorb(data);
  }
  digest() {
    return this.sha3.squeeze();
  }
};
var SHA3_256 = class {
  blockSize = 136;
  size = 32;
  sha3 = new SHA3(this.blockSize, this.size);
  update(data) {
    this.sha3.absorb(data);
  }
  digest() {
    return this.sha3.squeeze();
  }
};
var SHA3_384 = class {
  blockSize = 104;
  size = 48;
  sha3 = new SHA3(this.blockSize, this.size);
  update(data) {
    this.sha3.absorb(data);
  }
  digest() {
    return this.sha3.squeeze();
  }
};
var SHA3_512 = class {
  blockSize = 72;
  size = 64;
  sha3 = new SHA3(this.blockSize, this.size);
  update(data) {
    this.sha3.absorb(data);
  }
  digest() {
    return this.sha3.squeeze();
  }
};

// node_modules/@oslojs/crypto/dist/sha3/xof.js
function shake128(size, data) {
  const hash = new SHAKE128(size);
  hash.update(data);
  return hash.digest();
}
function shake256(size, data) {
  const hash = new SHAKE256(size);
  hash.update(data);
  return hash.digest();
}
var SHAKE128 = class {
  blockSize = 168;
  size;
  sha3;
  constructor(size) {
    if (size < 1) {
      throw new TypeError("Invalid hash size");
    }
    this.size = size;
    this.sha3 = new SHA3XOF(this.blockSize, this.size);
  }
  update(data) {
    this.sha3.absorb(data);
  }
  digest() {
    return this.sha3.squeeze();
  }
};
var SHAKE256 = class {
  blockSize = 136;
  size;
  sha3;
  constructor(size) {
    this.size = size;
    this.sha3 = new SHA3XOF(this.blockSize, this.size);
  }
  update(data) {
    this.sha3.absorb(data);
  }
  digest() {
    return this.sha3.squeeze();
  }
};
export {
  SHA3_224,
  SHA3_256,
  SHA3_384,
  SHA3_512,
  SHAKE128,
  SHAKE256,
  sha3_224,
  sha3_256,
  sha3_384,
  sha3_512,
  shake128,
  shake256
};
//# sourceMappingURL=@oslojs_crypto_sha3.js.map
